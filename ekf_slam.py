# -*- coding: utf-8 -*-
"""
Created on Thu Feb  2 18:10:04 2023

@author: Hp
"""


import localization_constants 
import robot_params
import numpy as np 
import math
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
import matplotlib.transforms as transforms

# Input --> Lidar_data, robot_pos, unrobot_pos, delta L, delta R, covariance: P
# Output --> Corrected Robot Pos, unrobot_pos

class EKF_slam():
    
    #Declare constants nad process lidar data
    def __init__(self):
    
        # Declaring Constants 
        
        self.robot_state = np.zeros(shape=(3, 1))
        self.robot_state_cov = np.zeros(shape=(3,3))
        self.landmarks = []
        self.flags = []
        pass
        
    # Perform the entire localize and mapping algorithm   
    # Inputs --> None
    # Outputs --> Corrected Robot Pos, unrobot_pos
    
    
    def localize_and_map(self, odometry_data, Lidar_data, robotPos,unlocalized_pos, SR, SL) -> list:
        
        # Preprocess Lidar Data        
        [lidarTime, robotX_actual, robotY_actual, robotTheta_actual, \
            num_points, scanning_angle, start_angle, step_size, lidar_data] \
            = self.process_lidar_data(Lidar_data)
        
        

        # Extract the Odometry Data --> get SL and SR
        [_, SL, SR] = odometry_data
        
    
        # Extract Local Variables 
        robotX, robotY, robotTheta = robotPos
        Q = self.get_Q(SR, SL)
        R = localization_constants.R
        
        # Propagate Robot --> Poshat, unrobot
        [robotX_hat, robotY_hat, robotTheta_hat] = self.get_pred_pos(SL, SR, robotPos)
        unlocalized_pos = self.get_pred_pos(SR, SL, unlocalized_pos)
 
        # Compute Jacobians 
        Fu = self.get_Fu(SR, SL, robotTheta_hat, self.robot_state.shape)
        Fp = self.get_Fp(SR, SL, robotTheta_hat, self.robot_state.shape)
        
        
        # Update pred cov     
        P_hat = self.get_Phat(Fu, Fp, Q)
# =============================================================================
#         print('phat ', P_hat)
# =============================================================================
        # Obtain Correspondences  
        Cylinder_pairs = self.get_cylinder_pairs(lidar_data, robotPos)
        
        
        
        
        # Add Landmark to state 
        #self.add_landmark_to_state(landmark)
        
        
        # Beginning Loop for observations
        
        # sum of kalman gains
        
        K_z = np.zeros(shape=(self.robot_state.shape))
        K_h = np.zeros(shape=(self.robot_state_cov.shape))
        
        for obs in range(len(Cylinder_pairs[0])):
            
            
            # Obtain Observations 
            z = self.get_measured_observations(Cylinder_pairs, obs)
            
            # Obtain Predicted Observations          
            zhat = self.get_pred_obs(robotPos)
            
            # Compute Obs Jacobians         
            H = self.compute_obs_jacobian(Cylinder_pairs, obs, robotPos)
            
            # Compute Kalman Gain 
            K = self.compute_kalman_gain(P_hat, H, R )
            
            # Compute innovation 
            innovation = self.get_innovation(z, zhat)
            
            # Add to cumulative matrix 
            
            K_z = self.update_Kz(K_z, K, innovation)
            K_h = self.update_Kh(K_h, K, innovation)
 
            
        # Update State 
        
        robotX, robotY, robotTheta = self.update_pos(K_z)
        self.update_uncertainity(K_h)

        return [robotX, robotY, robotTheta]
        
    def get_pred_pos(self,SR,SL, robotPos )-> list:
        
        robotX, robotY, robotTheta = robotPos
        b = robot_params.pioneer_track_width
        
        delta_trans = (SL + SR) / 2 
        #delta_theta = (SR- SL) / (2 * b)
        
        robotX = robotX + delta_trans * math.cos(robotTheta + (SR- SL) / (2 * b))
        robotY = robotY + delta_trans * math.sin(robotTheta + (SR- SL) / (2 * b))
        
        robotTheta = robotTheta + (SR - SL) / ( b)
        
        self.robot_state[0,0] = robotX
        self.robot_state[1,0] = robotY
        self.robot_state[2,0] = robotTheta
        
        
        return [robotX, robotY, robotTheta]


    def process_lidar_data(self, data):
        
        sysTime = data[1]
        
        robotX_actual = data[2]
        robotY_actual = data[3]
        robotTheta_actual = data[4]
        
        num_points = int(data[5])
        scanning_angle = data[6]
        start_angle = 0
        
        step_size = data[8]
        
        lidar_data = data[9:]
        
        lidar_data_processed = []
        angle = start_angle
        
        for i in range(num_points):
            
            lidar_data_processed.append([angle, lidar_data[i]])
            angle+= step_size
            
            
        return [sysTime, robotX_actual, robotY_actual, robotTheta_actual, \
            num_points, scanning_angle, start_angle, step_size, lidar_data_processed]
    
    def get_Q(self, SR, SL):
        k = localization_constants.model_cov_const
        Q = np.array([[k * abs(SR), 0], [0 , k * abs(SL)]])
        return Q
        
    
    def get_Fu(self, SR, SL, theta, robot_state_shape ):
        
        delta_D = (SR +  SL ) / 2
        delta_theta = (SR - SL) / robot_params.pioneer_track_width
        L = robot_params.pioneer_track_width
        
        Fu1 =  np.array(  [[1/2 * math.cos(theta + delta_theta /2) - delta_D / (2 * L) * math.sin(theta + delta_theta / 2), 1/2 * math.cos(theta + delta_theta /2) + delta_D / (2 * L) * math.sin(theta + delta_theta / 2)       ], \
                         [1/2 * math.sin(theta + delta_theta /2) + delta_D / (2 * L) * math.cos(theta + delta_theta / 2), 1/2 * math.sin(theta + delta_theta /2) - delta_D / (2 * L) * math.cos(theta + delta_theta / 2)       ], \
                         [1 / L, -1/L]    ] ) 
        
        Fu = np.zeros(shape=(robot_state_shape[0], 2))
        
        Fu[0:3,:] = Fu1
        
        return Fu
    
    def get_Fp(self, SR, SL, theta, robot_state_shape):
        
        
        delta_D = (SR + SL ) / 2
        delta_theta = (SR - SL) / robot_params.pioneer_track_width
        L = robot_params.pioneer_track_width
        
        Fp1 = np.array(  [[1, 0 , -delta_D * math.sin(theta + delta_theta / 2)], \
                         [0, 1, delta_D * math.cos(theta + delta_theta / 2)], \
                         [0, 0, 1] ]   )
        
        Fp2 = np.eye(robot_state_shape[0]-3)
        Fp = np.zeros(shape=(robot_state_shape[0],robot_state_shape[0] ))
        
        #print(Fp.shape)
        Fp[0:3, 0:3] = Fp1
        Fp[3:, 3:] = Fp2
        
        return Fp
            
    
    def get_Phat(self,Fu, Fp, Q):
# =============================================================================
#         
#         print('Fu shape', Fu.shape)
#         print('Fp shape', Fp.shape)
#         print('Q.shjape', Q.shape)
# =============================================================================
        
        L_matrix = np.matmul(np.matmul(Fp, self.robot_state_cov), np.transpose(Fp)) 
        R_matrix = np.matmul(np.matmul(Fu, Q), np.transpose(Fu))
        P_hat = np.add(L_matrix, R_matrix)
        self.robot_state_cov = P_hat
# =============================================================================
#         print('Phat shape', P_hat.shape)
# =============================================================================
        return P_hat 
    
    
    def compute_derivative(self, lidar_data):
        derivative = []
        for i in range(1,len(lidar_data)-1):
            l = lidar_data[i-1][1]
            r = lidar_data[i+1][1]
            d = (r- l)/2
            derivative.append(d)
              
        return derivative
    
        
    def find_cylinders(self, robotX, robotY, robotTheta, lidar_data):
        
        derivative = self.compute_derivative(lidar_data)
        cylinders = []
        start = False
        for i in range(len(derivative)):
    
            if derivative[i] < -localization_constants.cylinder_threshold_derivative :
                start = True
                avg_angle = 0
                n_indices = 0
                avg_depth = 0
                n_indices = 0
                avg_depth = 0 
                avg_indice = 0
                start = True
            if start == True and derivative[i] > localization_constants.cylinder_threshold_derivative \
                and n_indices > 0:
                avg_indice  = avg_indice / n_indices
                avg_angle = avg_angle / n_indices
                avg_depth = avg_depth / n_indices + localization_constants.cylinder_offset
                if avg_depth> 0.2:
                    theta = robotTheta + avg_angle -math.pi/2
                    x = robotX + avg_depth * math.cos(theta)
                    y = robotY + avg_depth * math.sin(theta)                
                    cylinders.append([x, y, avg_depth, avg_angle])
                
                start = False
            if start == True:
                avg_angle += lidar_data[i+1][0]
                avg_indice += i
                n_indices += 1
                avg_depth += lidar_data[i+1][1]
            
        
        return cylinders, derivative
        
    
    def get_dist(self, p1, p2):
        return math.sqrt( (p1[0] - p2[0])**2 + (p1[1]- p2[1])**2   )
            
        
    def get_cylinder_pairs(self, lidar_data, robotPos):
        
        robotX, robotY, robotTheta = robotPos
        [cylinders, derivatives] = self.find_cylinders(robotX, robotY, robotTheta, lidar_data)
        
        cylinder_pairs = []
        measured_cyl_coords = []
        predicted_cyl_coords = []
        world_cylinders = self.landmarks
        
       
        for i in range(len(cylinders)):
            
            min_dist = localization_constants.cylinder_threshold
            cyl_coords = []
            
            for j in range(len(world_cylinders)):
                
                dist = self.get_dist(cylinders[i][0:2], world_cylinders[j][:]) 
                
                if dist < min_dist:
                    min_dist = dist 
                    cyl_coords = world_cylinders[j][1:]
            if cyl_coords:
                measured_cyl_coords.append(cylinders[i])
                predicted_cyl_coords.append(cyl_coords)
                
            else:
                self.add_landmark_to_state((cylinders[i][0], cylinders[i][1]))
                self.landmarks.append([cylinders[i][0], cylinders[i][1]])
                self.flags.append(False)
                
        cylinder_pairs = [measured_cyl_coords, predicted_cyl_coords]
        
        return cylinder_pairs
    
    def add_landmark_to_state(self, landmark):
        
        x, y = landmark 
        
# =============================================================================
#         print('robot state before adding landmark', self.robot_state)
# =============================================================================
        
        state_size = self.robot_state.shape[0]
        robot_state = np.zeros(shape=(state_size+2, 1))

        
        robot_state[0:state_size, :] = self.robot_state
        robot_state[state_size, 0] = x
        robot_state[state_size+1, 0] = y
        
        self.robot_state = robot_state
# =============================================================================
#         print('robot state after adding landmark', self.robot_state)
#     
#         print('State Covariance before adding landmark')
# =============================================================================
# =============================================================================
#         print(self.robot_state_cov.shape)
# =============================================================================
        
        
        robot_state_cov = np.zeros(shape=(state_size+2,state_size+2))
        
        robot_state_cov[0:state_size, 0:state_size] = self.robot_state_cov
        robot_state_cov[state_size:, state_size:] = np.eye(2) * (10**10)
        self.robot_state_cov = robot_state_cov
        
        n_landmarks = len(self.landmarks)
        self.landmarks.append([n_landmarks, x, y])
        
# =============================================================================
#         print('state_covariance after adding state')
# =============================================================================
# =============================================================================
#         print(self.robot_state_cov.shape)
# =============================================================================
    
    
    
    def get_measured_observations(self, Cylinder_pairs, obs):
        
        measured_cyl_coord = Cylinder_pairs[0][obs]
        
        r = measured_cyl_coord[2]
        alpha = measured_cyl_coord[3]
    
        
        z = np.array([[r], [alpha]])
        return z         
        

    def get_pred_obs(self, Cylinder_pairs, obs, robotPos):
        
        xm, ym = Cylinder_pairs[1][obs]
        robotX, robotY, robotTheta = robotPos
        r = math.sqrt((xm - robotX)**2 + (ym - robotY)**2)
        
        alpha = math.atan2(ym-robotY, xm-robotX) + math.pi/2 - robotTheta
        if alpha > math.pi:
            alpha = -(2 * math.pi - alpha)
        
        if alpha < -math.pi:
            alpha = 2 * math.pi + alpha
        
        zhat = np.array([[r], [alpha]])       
        return zhat 
    
    def compute_obs_jacobian(self, Cylinder_pairs, obs, robotPos):
        
        H = np.zeros(shape=(2, self.robot_state.shape[0]))
        xm, ym = Cylinder_pairs[1][obs]
        robotX, robotY, robotTheta = robotPos
        
        dx = xm - robotX
        dy = ym - robotY
        
        q = (xm - robotX)**2 + (ym - robotY)**2
        root_q = math.sqrt(q)
        
        H1 = np.array([[ -dx/root_q, -dy/root_q, 0],[ dy/q, -dx/ q, -1 ]])
        H2 = - H1[:, 0:2]
        
        if self.flag[obs]:
            H[:,0:3] = H1 
        
        H[:, obs*2+3:obs*2+5] = H2
        
        return H
        

    def compute_kalman_gain(self,P_hat, H, R ):
        
# =============================================================================
#         print('phat shape', P_hat.shape)
#         print('H shape', H.shape)
#         print('R shape', R.shape)
# =============================================================================
        
        T =   np.linalg.inv(    np.add(np.matmul(np.matmul(H, P_hat), np.transpose(H)), R))
        K = np.matmul( np.matmul(P_hat, np.transpose(H)), T)
        return K 
    
    def get_innovation(self, z, zhat):
        
        innovation = np.subtract(z, zhat)
        
        if innovation[1,0] > math.pi:
            innovation[1,0] = innovation[1,0] - 2 * math.pi
            
        if innovation[1,0] < -math.pi:
            innovation[1,0] = innovation[1, 0] + math.pi * 2
        
        return innovation
        

    
    def update_Kz(self, K_z, K, innovation):
        
        K_z = np.add(K_z, np.matmul(K,innovation))
        return K_z   
        
    def update_Kh(self, K_h,H, K, innovation):
        
        K_h = np.add(K_h, np.matmul(K,H ))
        return K_h
        
    
    def update_pos(self, K_z ):
        
        self.robot_state = np.add(self.robot_state, K_z)
        
        return [self.robot_state[0],self.robot_state[1],self.robot_state[2]]


    def update_uncertainity(self, K_h):
        I= np.eye(self.robot_state.shape[0])
# =============================================================================
#         print('Kh shape', K_h.shape)
#         print('T shpae', I.shape)
#         print('Phat shpae', self.robot_state_cov)
# =============================================================================
        T = np.subtract(I, K_h)
        P = np.matmul(T, self.robot_state_cov)
        self.robot_state_cov = P
        
    def confidence_ellipse(self, x, y,cov, n_std=3.0, facecolor='none', **kwargs):
            
        
        pearson = cov[0, 1]/np.sqrt(cov[0, 0] * cov[1, 1])
        # Using a special case to obtain the eigenvalues of this
        # two-dimensional dataset.
        ell_radius_x = np.sqrt(1 + pearson)
        ell_radius_y = np.sqrt(1 - pearson)
        ellipse = Ellipse((0, 0), width=ell_radius_x * 2, height=ell_radius_y * 2,
                          facecolor=facecolor, **kwargs)
    
        # Calculating the standard deviation of x from
        # the squareroot of the variance and multiplying
        # with the given number of standard deviations.
        scale_x = np.sqrt(cov[0, 0]) * n_std
        
    
        # calculating the standard deviation of y ...
        scale_y = np.sqrt(cov[1, 1]) * n_std

    
        transf = transforms.Affine2D() \
            .rotate_deg(45) \
            .scale(scale_x, scale_y) \
            .translate(x, y)
            
        ellipse.set_transform(transf)
        
        return ellipse
            
        
    
def plot_cylinder_pairs(Cylinder_pairs):
    pred, act = Cylinder_pairs 
    for  p, a in zip(pred, act):
        #print(p, a)
        
        plt.scatter(p[0], p[1], c='b')
        plt.scatter(a[0], a[1], c='r')


if __name__ =="__main__":
    
    # Test Input for each function 
    slam_obj = EKF_slam()
# =============================================================================
#     # Testing Fu 
#     print('Testing Fu')
#     SL = 1
#     SR = 1
#     
#     Theta = 0 
#     robot_state = np.zeros(shape=(5,1))
#     robot_state_shape = robot_state.shape
#     
#     
#     print('Testing P')
#     P = np.eye(robot_state_shape[0]) * 0.00001
#     print("P: ")
#     print(P)
#     
#     
#     Fu = slam_obj.get_Fu(SR, SL, Theta, robot_state_shape)
#     print('Fu: ')
#     print(Fu)
#     
#     
#     # Testing Fp 
#     
#     print('Testing Fp')
#   
#     Fp = slam_obj.get_Fp(SR, SL, Theta, robot_state_shape)
#     print('Fp: ')
#     print(Fp)
#     
#     
#     # Testing Q 
#     print('Testing Q')
#     Q = slam_obj.get_Q(SR, SL)
#     print(Q)
#     
#     
#     
#     print('Testing Phat')
#     
#     
#     P_hat = slam_obj.get_Phat(P, Fu, Fp, Q)
#     print(P_hat)
#     
# =============================================================================
# =============================================================================
#     
# # Testing Lidar data  
# robotPos = [0, 0, 0]
# lidar_data = [-1.0, 674.9080200195312, 0.9797943830490112, -2.1501259803771973, -0.00015048604109324515, 721.0, 3.1415927410125732, -1.5707963705062866, 0.004363323096185923, 5.175136566162109, 5.175180912017822, 5.175325393676758, 5.17556619644165, 5.175909519195557, 5.1763482093811035, 5.176886558532715, 5.1775221824646, 5.178259372711182, 5.179093837738037, 5.180027008056641, 5.181057929992676, 5.182190895080566, 5.1834211349487305, 5.184750556945801, 5.186180114746094, 5.187709808349609, 5.189337253570557, 5.191066741943359, 5.192896842956543, 5.19482421875, 5.196831703186035, 5.198960304260254, 5.201189994812012, 5.203522205352783, 5.20595645904541, 5.208489418029785, 5.21112585067749, 5.213863849639893, 5.216705799102783, 5.219647407531738, 5.222692489624023, 5.225841522216797, 5.229093074798584, 5.23245096206665, 5.235910892486572, 5.239474296569824, 5.243143558502197, 5.246918678283691, 5.25079870223999, 5.25478458404541, 5.258875846862793, 5.2630743980407715, 5.267378807067871, 5.271792411804199, 5.2763142585754395, 5.280943870544434, 5.285681247711182, 5.290530681610107, 5.295487403869629, 5.300553798675537, 5.305734157562256, 5.3110222816467285, 5.31642484664917, 5.321939468383789, 5.3275675773620605, 5.33330774307251, 5.339162349700928, 5.3451313972473145, 5.351217269897461, 5.357418060302734, 5.363736152648926, 5.370171070098877, 5.376723766326904, 5.383394241333008, 5.390185832977295, 5.397097110748291, 5.404128074645996, 5.411280632019043, 5.418557643890381, 5.425954818725586, 5.433476448059082, 5.441123962402344, 5.448896884918213, 5.456795692443848, 5.464820384979248, 5.47297477722168, 5.48125696182251, 5.489669322967529, 5.4982123374938965, 5.506887435913086, 5.515695095062256, 5.524634838104248, 5.533709526062012, 5.54292106628418, 5.552269458770752, 5.561753273010254, 5.571376800537109, 5.581142902374268, 5.591046333312988, 5.60109281539917, 5.6112823486328125, 5.621617317199707, 5.632098197937012, 5.642723560333252, 5.653499603271484, 5.664422988891602, 5.6754961013793945, 5.686722755432129, 5.69810152053833, 5.709636211395264, 5.721303462982178, 5.733152389526367, 5.745159149169922, 5.757324695587158, 5.7696533203125, 5.782144069671631, 5.794799327850342, 5.807621955871582, 5.82061243057251, 5.833772659301758, 5.847103118896484, 5.8606061935424805, 5.874286651611328, 5.888139724731445, 5.902173042297363, 5.916386127471924, 5.930780410766602, 5.945359706878662, 5.960124492645264, 5.975076198577881, 5.990216255187988, 6.005550384521484, 6.021076679229736, 6.03679895401001, 6.052717685699463, 6.0688371658325195, 6.085160255432129, 6.101687431335449, 6.1184210777282715, 6.135363578796387, 6.152516841888428, 6.16988468170166, 6.187471389770508, 6.205275058746338, 6.223299026489258, 6.241549968719482, 6.260025501251221, 6.278733253479004, 6.29766845703125, 6.316843509674072, 6.336254596710205, 6.35590934753418, 6.375804901123047, 6.395947456359863, 6.4163432121276855, 6.43699312210083, 6.457894802093506, 6.479058742523193, 6.500487804412842, 6.522182464599609, 6.544145584106445, 6.566385269165039, 6.5888991355896, 6.61169958114624, 6.6347808837890625, 6.658151149749756, 6.6818156242370605, 6.705777645111084, 6.730040550231934, 6.754608154296875, 6.779484748840332, 6.804673671722412, 6.830092430114746, 6.855925559997559, 6.88208532333374, 6.908576011657715, 6.935405731201172, 6.9625773429870605, 6.990095615386963, 7.0179667472839355, 7.046197891235352, 7.0747904777526855, 7.103750228881836, 7.133088111877441, 7.162803649902344, 7.192905902862549, 7.2234015464782715, 7.254293441772461, 7.285592555999756, 7.3173017501831055, 7.349428653717041, 7.3819780349731445, 7.414963245391846, 7.448379993438721, 2.572051525115967, 2.5382204055786133, 2.518048048019409, 2.4990811347961426, 2.484938621520996, 2.472815752029419, 2.4608561992645264, 2.451702356338501, 2.4438669681549072, 2.436129570007324, 2.428485870361328, 2.423630952835083, 2.418923854827881, 2.41428279876709, 2.409703254699707, 2.406832695007324, 2.404646635055542, 2.4025115966796875, 2.4004249572753906, 2.39868426322937, 2.3987741470336914, 2.3989086151123047, 2.3990893363952637, 2.399315357208252, 2.400554895401001, 2.4029719829559326, 2.405440092086792, 2.407958507537842, 2.410529375076294, 2.415297031402588, 2.420325994491577, 2.4254238605499268, 2.4305877685546875, 2.437964677810669, 2.4462127685546875, 2.4545631408691406, 2.4634809494018555, 2.476205825805664, 2.489110231399536, 2.5035951137542725, 2.523998498916626, 2.546333074569702, 2.584092855453491, 7.596881866455078, 7.575480937957764, 7.554343223571777, 7.533468723297119, 7.512848854064941, 7.492486953735352, 7.472374439239502, 7.452510356903076, 7.432895660400391, 7.413521766662598, 7.394392490386963, 7.375500202178955, 7.356842517852783, 7.338418006896973, 6.598440647125244, 6.536351680755615, 6.499196529388428, 6.472776412963867, 6.45357084274292, 6.440618991851807, 6.430373668670654, 6.4249186515808105, 6.422458171844482, 6.422821521759033, 6.427595615386963, 6.434178352355957, 6.446685314178467, 6.462834358215332, 6.483730792999268, 6.514400482177734, 6.5595598220825195, 7.0441436767578125, 7.029738426208496, 7.015523910522461, 7.001502990722656, 6.987668037414551, 6.974022388458252, 6.9605607986450195, 6.947282791137695, 6.934188365936279, 6.921273708343506, 6.908538341522217, 6.895981311798096, 6.883600234985352, 6.871394157409668, 6.859362602233887, 6.847503185272217, 6.835812568664551, 6.824294090270996, 6.8129425048828125, 6.801758766174316, 6.790739059448242, 6.7798848152160645, 6.76919412612915, 6.758665084838867, 6.748297691345215, 6.7380900382995605, 6.7280402183532715, 6.718148231506348, 6.708413600921631, 6.698835849761963, 6.6894097328186035, 6.680137634277344, 6.671018123626709, 6.662052154541016, 6.65323543548584, 6.644568920135498, 6.636049747467041, 6.627678394317627, 6.619455814361572, 6.611377239227295, 6.603445053100586, 6.595656394958496, 6.5880126953125, 6.580511569976807, 6.5731520652771, 6.565934658050537, 6.558856010437012, 6.5519185066223145, 6.5451202392578125, 6.538459300994873, 6.5319390296936035, 6.525554180145264, 6.519305229187012, 6.513190746307373, 6.50721549987793, 6.501370429992676, 6.495662689208984, 6.490087032318115, 6.484645366668701, 6.479333877563477, 6.474155426025391, 6.4691081047058105, 6.464191913604736, 6.45940637588501, 6.454751014709473, 6.450223445892334, 6.445825099945068, 6.441556930541992, 6.437416076660156, 6.433403491973877, 6.4295172691345215, 6.42575740814209, 6.422126293182373, 6.4186201095581055, 6.415240287780762, 6.411985874176025, 6.4088568687438965, 6.405850887298584, 6.4029717445373535, 6.400216579437256, 6.397585391998291, 6.395079135894775, 6.392693519592285, 6.390433311462402, 6.3882975578308105, 6.3862833976745605, 6.384389877319336, 6.382621765136719, 6.38097620010376, 6.379452705383301, 6.378049373626709, 6.376769542694092, 6.375612258911133, 6.374576091766357, 6.373661518096924, 6.372867584228516, 6.372195720672607, 6.371645450592041, 6.371217727661133, 6.370911121368408, 6.370723247528076, 6.370658874511719, 6.370716094970703, 6.370892524719238, 6.371192932128906, 6.371611595153809, 6.37215518951416, 5.810803413391113, 5.718668460845947, 5.678725242614746, 5.650766849517822, 5.631328105926514, 5.615034580230713, 5.603481769561768, 5.594771385192871, 5.58890438079834, 5.585817337036133, 5.5850653648376465, 5.58699893951416, 5.5912909507751465, 5.598585605621338, 5.608329772949219, 5.622490882873535, 5.638947010040283, 5.663588047027588, 5.696316719055176, 5.747094631195068, 6.411764621734619, 6.415011405944824, 6.4183831214904785, 6.421879768371582, 6.425503730773926, 6.429254055023193, 6.433131217956543, 6.437135696411133, 6.441267013549805, 6.445528507232666, 6.449915885925293, 6.454433441162109, 6.459080696105957, 6.463857173919678, 6.468764781951904, 6.473801612854004, 6.478971481323242, 6.4842729568481445, 6.489706993103027, 6.495272159576416, 6.500972747802734, 6.506806373596191, 6.512775421142578, 6.518878936767578, 6.525117874145508, 6.531494140625, 6.5380072593688965, 6.544656276702881, 6.551445960998535, 6.55837345123291, 6.565440654754639, 6.572649955749512, 6.579998970031738, 6.587491512298584, 6.595125675201416, 6.602903366088867, 6.6108269691467285, 6.618894100189209, 6.627109527587891, 6.635467529296875, 6.643976211547852, 6.652632236480713, 6.661439418792725, 6.670395374298096, 6.679503917694092, 6.688766002655029, 6.69818115234375, 6.707747936248779, 6.717471122741699, 6.727353096008301, 6.737391471862793, 6.747588157653809, 6.757944583892822, 6.768463134765625, 6.7791428565979, 6.789984703063965, 6.800992965698242, 6.812166690826416, 6.823505401611328, 6.835013389587402, 6.846690654754639, 6.8585381507873535, 6.870558261871338, 6.882751941680908, 6.895121097564697, 6.907665729522705, 2.8543567657470703, 2.7928037643432617, 2.762665271759033, 2.741217613220215, 2.723689079284668, 2.7100486755371094, 2.6965949535369873, 2.6866605281829834, 2.677839756011963, 2.669126510620117, 2.6618194580078125, 2.656407356262207, 2.6510674953460693, 2.6457998752593994, 2.642054557800293, 2.6394460201263428, 2.636892318725586, 2.634394407272339, 2.6329073905944824, 2.632805585861206, 2.632753849029541, 2.6327526569366455, 2.633148193359375, 2.63553786277771, 2.63798189163208, 2.6404802799224854, 2.6430346965789795, 2.6481432914733887, 2.653350591659546, 2.6586310863494873, 2.6643898487091064, 2.6729259490966797, 2.6815671920776367, 2.6903162002563477, 2.7024641036987305, 2.7158210277557373, 2.729475498199463, 2.7503857612609863, 2.771674156188965, 2.809077024459839, 6.019528388977051, 7.6170454025268555, 7.638964653015137, 7.6611552238464355, 7.683623790740967, 7.706368446350098, 7.729398727416992, 7.752713680267334, 7.776317119598389, 7.800215244293213, 7.794161796569824, 7.74683141708374, 7.70021390914917, 7.654303550720215, 7.609075546264648, 7.564528465270996, 7.520639896392822, 7.477396488189697, 7.4347920417785645, 7.3928093910217285, 7.351435661315918, 7.310662269592285, 7.270474433898926, 7.230865955352783, 7.191821575164795, 7.153331756591797, 7.115386486053467, 7.077976703643799, 7.041091442108154, 7.004721164703369, 6.9688544273376465, 6.9334869384765625, 6.898606777191162, 6.864204406738281, 6.8302741050720215, 6.796806335449219, 6.763792991638184, 6.731226921081543, 6.699099063873291, 6.6674017906188965, 6.6361308097839355, 6.605275630950928, 6.574833869934082, 6.5447893142700195, 6.515145778656006, 6.485893726348877, 6.457024097442627, 6.428531169891357, 6.4004082679748535, 6.372654914855957, 6.345207691192627, 6.318167209625244, 6.29147481918335, 6.265127182006836, 6.239115238189697, 6.213438034057617, 6.1880879402160645, 6.16306209564209, 6.1383538246154785, 6.113958358764648, 6.089870929718018, 6.066088676452637, 6.042604923248291, 6.0194172859191895, 5.99652099609375, 5.973909854888916, 5.951583385467529, 5.929533004760742, 5.9077606201171875, 5.886258125305176, 5.8650221824646, 5.84404993057251, 5.823337554931641, 5.802882671356201, 5.782680034637451, 5.7627272605896, 5.743020057678223, 5.723556041717529, 5.704329967498779, 5.6853437423706055, 5.666589260101318, 5.648065090179443, 5.629768371582031, 5.611696720123291, 5.593847274780273, 5.576216697692871, 5.558801174163818, 5.541601181030273, 5.524610996246338, 5.507828712463379, 5.49125337600708, 5.474881649017334, 5.458709239959717, 5.442737579345703, 5.426959991455078, 5.411378383636475, 5.395987510681152, 5.3807854652404785, 5.365771770477295, 5.350942611694336, 5.336297035217285, 5.321832180023193, 5.307546138763428, 5.293436050415039, 5.279501914978027, 5.265741348266602, 5.252151966094971, 5.238731861114502, 5.225479602813721, 5.212392807006836, 5.199471473693848, 5.186710834503174, 5.174088478088379, 5.161648750305176, 5.1493659019470215, 5.137239456176758, 5.125267028808594, 5.113447189331055, 5.101779460906982, 5.090260982513428, 5.078890800476074, 5.067667007446289, 5.056589603424072, 5.045656204223633, 5.034865379333496, 5.024216175079346, 5.013708114624023, 5.003337383270264, 4.993104934692383, 4.9830098152160645, 4.973048210144043, 4.963222980499268, 4.95352840423584, 4.943966865539551, 4.934535026550293, 4.925233364105225, 4.916059494018555, 4.907012939453125, 4.8980937004089355, 4.8892998695373535, 4.880629062652588, 4.872082710266113, 4.072032928466797, 3.998302698135376, 3.966073751449585, 3.9414217472076416, 3.9218642711639404, 3.9066898822784424, 3.8938684463500977, 3.882819890975952, 3.874840021133423, 3.8669657707214355, 3.8619132041931152, 3.8579494953155518, 3.8540663719177246, 3.8532791137695312, 3.852914571762085, 3.852623224258423, 3.8556814193725586, 3.8588790893554688, 3.8625941276550293, 3.869584321975708, 3.8766725063323975, 3.8857944011688232, 3.897467851638794, 3.909691333770752, 3.9275567531585693, 3.9465341567993164, 3.974195957183838, 4.013400077819824, 4.6740031242370605, 4.668774127960205, 4.663647651672363, 4.6586198806762695, 4.653691291809082, 4.648862838745117, 4.644130706787109, 4.639497756958008, 4.63496208190918, 4.630522727966309, 4.626180648803711, 4.621934413909912, 4.617784023284912, 4.613729000091553, 4.609766960144043, 4.605901718139648, 4.602129936218262, 4.598450660705566, 4.594865798950195, 4.591372489929199, 4.587973594665527, 4.5846662521362305, 4.581450462341309, 4.578325271606445, 4.575293064117432, 4.572351455688477, 4.5695013999938965, 4.566739559173584, 4.5640692710876465, 4.561488628387451, 4.5589985847473145, 4.556598663330078, 4.554262161254883, 4.552038192749023, 4.549903869628906, 4.547857284545898, 4.545900821685791, 4.544031143188477, 4.54224967956543, 4.540555477142334, 4.538949966430664, 4.537431716918945, 4.535999774932861, 4.534657001495361, 4.53339958190918, 4.532230377197266, 4.531147003173828, 4.530149936676025, 4.52924108505249, 4.528416633605957, 4.527681350708008, 4.527030944824219, 4.5264668464660645, 4.525989532470703, 4.525599479675293, 4.525293827056885, 4.525074005126953, 4.524942874908447, 4.524895191192627]
#     
# [lidarTime, robotX_actual, robotY_actual, robotTheta_actual, \
#  num_points, scanning_angle, start_angle, step_size, lidar_data] \
#             = slam_obj.process_lidar_data(lidar_data)
# print('len of liar data')
# print(len(lidar_data))    
#     
# robotPos = [robotX_actual, robotY_actual, robotTheta_actual]
# 
# # Testing cylinder detection 
# 
# Cylinder_pairs = slam_obj.get_cylinder_pairs(lidar_data, robotPos)
# print('Computing Cylinder Pairs')
# print(Cylinder_pairs)    
#     
# print('Plotting cylinder pairs')
# 
# plot_cylinder_pairs(Cylinder_pairs)
# plt.xlim(-3, 8)
# plt.ylim(-8,3)
# 
# 
# =============================================================================
    
# =============================================================================
# 
# # Testing adding landmarks 
# 
# 
# landmark = [1, 1]
# slam_obj.add_landmark_to_state(landmark)
# 
# 
# # Testing the z and zhat funciton 
# 
# # Defining cylinder pairs 
# 
# Cyl_pairs = [[[1, 1, math.sqrt(2), 3*math.pi/4]], [[-1, 1]]]
# 
# z = slam_obj.get_measured_observations(Cyl_pairs, 0)
# print('z = ')
# print(z)
# 
# robotPos = [0, 0, 0]
# zhat = slam_obj.get_pred_obs(Cyl_pairs, 0, robotPos)
# print('zhat')
# print(zhat)
# 
# 
# 
# # Code to check the H matrix funciton 
# 
# H = slam_obj.compute_obs_jacobian(Cyl_pairs, 0, robotPos)
# 
# print('Computing H')
# print(H)
# 
# # Code to test the Kalman Gain 
# 
# R = localization_constants.R
# K = slam_obj.compute_kalman_gain(P_hat, H, R)
# 
# print('Kalman Gain')
# print(K)
# 
# 
# 
# 
# # Testing Innovation
# 
# innovation = slam_obj.get_innovation(z, zhat)
# print('Innovation ')
# print(innovation)
# 
# 
# # Testing the Kz 
# K_z = np.zeros(shape=(slam_obj.robot_state.shape))
# K_h =  np.zeros(shape=(slam_obj.robot_state_cov.shape))
# 
# 
# K_z = slam_obj.update_Kz(K_z, K, innovation)
# 
# print('K_z ')
# print(K_z)
# 
# 
# K_h = slam_obj.update_Kh(K_h, K, innovation)
# 
# print('K_h')
# print(K_h)
# 
# 
# =============================================================================


# Testing the whole code with real lidar but no control input 


lidar_data = [-1.0, 674.9080200195312, 0.9797943830490112, -2.1501259803771973, -0.00015048604109324515, 721.0, 3.1415927410125732, -1.5707963705062866, 0.004363323096185923, 5.175136566162109, 5.175180912017822, 5.175325393676758, 5.17556619644165, 5.175909519195557, 5.1763482093811035, 5.176886558532715, 5.1775221824646, 5.178259372711182, 5.179093837738037, 5.180027008056641, 5.181057929992676, 5.182190895080566, 5.1834211349487305, 5.184750556945801, 5.186180114746094, 5.187709808349609, 5.189337253570557, 5.191066741943359, 5.192896842956543, 5.19482421875, 5.196831703186035, 5.198960304260254, 5.201189994812012, 5.203522205352783, 5.20595645904541, 5.208489418029785, 5.21112585067749, 5.213863849639893, 5.216705799102783, 5.219647407531738, 5.222692489624023, 5.225841522216797, 5.229093074798584, 5.23245096206665, 5.235910892486572, 5.239474296569824, 5.243143558502197, 5.246918678283691, 5.25079870223999, 5.25478458404541, 5.258875846862793, 5.2630743980407715, 5.267378807067871, 5.271792411804199, 5.2763142585754395, 5.280943870544434, 5.285681247711182, 5.290530681610107, 5.295487403869629, 5.300553798675537, 5.305734157562256, 5.3110222816467285, 5.31642484664917, 5.321939468383789, 5.3275675773620605, 5.33330774307251, 5.339162349700928, 5.3451313972473145, 5.351217269897461, 5.357418060302734, 5.363736152648926, 5.370171070098877, 5.376723766326904, 5.383394241333008, 5.390185832977295, 5.397097110748291, 5.404128074645996, 5.411280632019043, 5.418557643890381, 5.425954818725586, 5.433476448059082, 5.441123962402344, 5.448896884918213, 5.456795692443848, 5.464820384979248, 5.47297477722168, 5.48125696182251, 5.489669322967529, 5.4982123374938965, 5.506887435913086, 5.515695095062256, 5.524634838104248, 5.533709526062012, 5.54292106628418, 5.552269458770752, 5.561753273010254, 5.571376800537109, 5.581142902374268, 5.591046333312988, 5.60109281539917, 5.6112823486328125, 5.621617317199707, 5.632098197937012, 5.642723560333252, 5.653499603271484, 5.664422988891602, 5.6754961013793945, 5.686722755432129, 5.69810152053833, 5.709636211395264, 5.721303462982178, 5.733152389526367, 5.745159149169922, 5.757324695587158, 5.7696533203125, 5.782144069671631, 5.794799327850342, 5.807621955871582, 5.82061243057251, 5.833772659301758, 5.847103118896484, 5.8606061935424805, 5.874286651611328, 5.888139724731445, 5.902173042297363, 5.916386127471924, 5.930780410766602, 5.945359706878662, 5.960124492645264, 5.975076198577881, 5.990216255187988, 6.005550384521484, 6.021076679229736, 6.03679895401001, 6.052717685699463, 6.0688371658325195, 6.085160255432129, 6.101687431335449, 6.1184210777282715, 6.135363578796387, 6.152516841888428, 6.16988468170166, 6.187471389770508, 6.205275058746338, 6.223299026489258, 6.241549968719482, 6.260025501251221, 6.278733253479004, 6.29766845703125, 6.316843509674072, 6.336254596710205, 6.35590934753418, 6.375804901123047, 6.395947456359863, 6.4163432121276855, 6.43699312210083, 6.457894802093506, 6.479058742523193, 6.500487804412842, 6.522182464599609, 6.544145584106445, 6.566385269165039, 6.5888991355896, 6.61169958114624, 6.6347808837890625, 6.658151149749756, 6.6818156242370605, 6.705777645111084, 6.730040550231934, 6.754608154296875, 6.779484748840332, 6.804673671722412, 6.830092430114746, 6.855925559997559, 6.88208532333374, 6.908576011657715, 6.935405731201172, 6.9625773429870605, 6.990095615386963, 7.0179667472839355, 7.046197891235352, 7.0747904777526855, 7.103750228881836, 7.133088111877441, 7.162803649902344, 7.192905902862549, 7.2234015464782715, 7.254293441772461, 7.285592555999756, 7.3173017501831055, 7.349428653717041, 7.3819780349731445, 7.414963245391846, 7.448379993438721, 2.572051525115967, 2.5382204055786133, 2.518048048019409, 2.4990811347961426, 2.484938621520996, 2.472815752029419, 2.4608561992645264, 2.451702356338501, 2.4438669681549072, 2.436129570007324, 2.428485870361328, 2.423630952835083, 2.418923854827881, 2.41428279876709, 2.409703254699707, 2.406832695007324, 2.404646635055542, 2.4025115966796875, 2.4004249572753906, 2.39868426322937, 2.3987741470336914, 2.3989086151123047, 2.3990893363952637, 2.399315357208252, 2.400554895401001, 2.4029719829559326, 2.405440092086792, 2.407958507537842, 2.410529375076294, 2.415297031402588, 2.420325994491577, 2.4254238605499268, 2.4305877685546875, 2.437964677810669, 2.4462127685546875, 2.4545631408691406, 2.4634809494018555, 2.476205825805664, 2.489110231399536, 2.5035951137542725, 2.523998498916626, 2.546333074569702, 2.584092855453491, 7.596881866455078, 7.575480937957764, 7.554343223571777, 7.533468723297119, 7.512848854064941, 7.492486953735352, 7.472374439239502, 7.452510356903076, 7.432895660400391, 7.413521766662598, 7.394392490386963, 7.375500202178955, 7.356842517852783, 7.338418006896973, 6.598440647125244, 6.536351680755615, 6.499196529388428, 6.472776412963867, 6.45357084274292, 6.440618991851807, 6.430373668670654, 6.4249186515808105, 6.422458171844482, 6.422821521759033, 6.427595615386963, 6.434178352355957, 6.446685314178467, 6.462834358215332, 6.483730792999268, 6.514400482177734, 6.5595598220825195, 7.0441436767578125, 7.029738426208496, 7.015523910522461, 7.001502990722656, 6.987668037414551, 6.974022388458252, 6.9605607986450195, 6.947282791137695, 6.934188365936279, 6.921273708343506, 6.908538341522217, 6.895981311798096, 6.883600234985352, 6.871394157409668, 6.859362602233887, 6.847503185272217, 6.835812568664551, 6.824294090270996, 6.8129425048828125, 6.801758766174316, 6.790739059448242, 6.7798848152160645, 6.76919412612915, 6.758665084838867, 6.748297691345215, 6.7380900382995605, 6.7280402183532715, 6.718148231506348, 6.708413600921631, 6.698835849761963, 6.6894097328186035, 6.680137634277344, 6.671018123626709, 6.662052154541016, 6.65323543548584, 6.644568920135498, 6.636049747467041, 6.627678394317627, 6.619455814361572, 6.611377239227295, 6.603445053100586, 6.595656394958496, 6.5880126953125, 6.580511569976807, 6.5731520652771, 6.565934658050537, 6.558856010437012, 6.5519185066223145, 6.5451202392578125, 6.538459300994873, 6.5319390296936035, 6.525554180145264, 6.519305229187012, 6.513190746307373, 6.50721549987793, 6.501370429992676, 6.495662689208984, 6.490087032318115, 6.484645366668701, 6.479333877563477, 6.474155426025391, 6.4691081047058105, 6.464191913604736, 6.45940637588501, 6.454751014709473, 6.450223445892334, 6.445825099945068, 6.441556930541992, 6.437416076660156, 6.433403491973877, 6.4295172691345215, 6.42575740814209, 6.422126293182373, 6.4186201095581055, 6.415240287780762, 6.411985874176025, 6.4088568687438965, 6.405850887298584, 6.4029717445373535, 6.400216579437256, 6.397585391998291, 6.395079135894775, 6.392693519592285, 6.390433311462402, 6.3882975578308105, 6.3862833976745605, 6.384389877319336, 6.382621765136719, 6.38097620010376, 6.379452705383301, 6.378049373626709, 6.376769542694092, 6.375612258911133, 6.374576091766357, 6.373661518096924, 6.372867584228516, 6.372195720672607, 6.371645450592041, 6.371217727661133, 6.370911121368408, 6.370723247528076, 6.370658874511719, 6.370716094970703, 6.370892524719238, 6.371192932128906, 6.371611595153809, 6.37215518951416, 5.810803413391113, 5.718668460845947, 5.678725242614746, 5.650766849517822, 5.631328105926514, 5.615034580230713, 5.603481769561768, 5.594771385192871, 5.58890438079834, 5.585817337036133, 5.5850653648376465, 5.58699893951416, 5.5912909507751465, 5.598585605621338, 5.608329772949219, 5.622490882873535, 5.638947010040283, 5.663588047027588, 5.696316719055176, 5.747094631195068, 6.411764621734619, 6.415011405944824, 6.4183831214904785, 6.421879768371582, 6.425503730773926, 6.429254055023193, 6.433131217956543, 6.437135696411133, 6.441267013549805, 6.445528507232666, 6.449915885925293, 6.454433441162109, 6.459080696105957, 6.463857173919678, 6.468764781951904, 6.473801612854004, 6.478971481323242, 6.4842729568481445, 6.489706993103027, 6.495272159576416, 6.500972747802734, 6.506806373596191, 6.512775421142578, 6.518878936767578, 6.525117874145508, 6.531494140625, 6.5380072593688965, 6.544656276702881, 6.551445960998535, 6.55837345123291, 6.565440654754639, 6.572649955749512, 6.579998970031738, 6.587491512298584, 6.595125675201416, 6.602903366088867, 6.6108269691467285, 6.618894100189209, 6.627109527587891, 6.635467529296875, 6.643976211547852, 6.652632236480713, 6.661439418792725, 6.670395374298096, 6.679503917694092, 6.688766002655029, 6.69818115234375, 6.707747936248779, 6.717471122741699, 6.727353096008301, 6.737391471862793, 6.747588157653809, 6.757944583892822, 6.768463134765625, 6.7791428565979, 6.789984703063965, 6.800992965698242, 6.812166690826416, 6.823505401611328, 6.835013389587402, 6.846690654754639, 6.8585381507873535, 6.870558261871338, 6.882751941680908, 6.895121097564697, 6.907665729522705, 2.8543567657470703, 2.7928037643432617, 2.762665271759033, 2.741217613220215, 2.723689079284668, 2.7100486755371094, 2.6965949535369873, 2.6866605281829834, 2.677839756011963, 2.669126510620117, 2.6618194580078125, 2.656407356262207, 2.6510674953460693, 2.6457998752593994, 2.642054557800293, 2.6394460201263428, 2.636892318725586, 2.634394407272339, 2.6329073905944824, 2.632805585861206, 2.632753849029541, 2.6327526569366455, 2.633148193359375, 2.63553786277771, 2.63798189163208, 2.6404802799224854, 2.6430346965789795, 2.6481432914733887, 2.653350591659546, 2.6586310863494873, 2.6643898487091064, 2.6729259490966797, 2.6815671920776367, 2.6903162002563477, 2.7024641036987305, 2.7158210277557373, 2.729475498199463, 2.7503857612609863, 2.771674156188965, 2.809077024459839, 6.019528388977051, 7.6170454025268555, 7.638964653015137, 7.6611552238464355, 7.683623790740967, 7.706368446350098, 7.729398727416992, 7.752713680267334, 7.776317119598389, 7.800215244293213, 7.794161796569824, 7.74683141708374, 7.70021390914917, 7.654303550720215, 7.609075546264648, 7.564528465270996, 7.520639896392822, 7.477396488189697, 7.4347920417785645, 7.3928093910217285, 7.351435661315918, 7.310662269592285, 7.270474433898926, 7.230865955352783, 7.191821575164795, 7.153331756591797, 7.115386486053467, 7.077976703643799, 7.041091442108154, 7.004721164703369, 6.9688544273376465, 6.9334869384765625, 6.898606777191162, 6.864204406738281, 6.8302741050720215, 6.796806335449219, 6.763792991638184, 6.731226921081543, 6.699099063873291, 6.6674017906188965, 6.6361308097839355, 6.605275630950928, 6.574833869934082, 6.5447893142700195, 6.515145778656006, 6.485893726348877, 6.457024097442627, 6.428531169891357, 6.4004082679748535, 6.372654914855957, 6.345207691192627, 6.318167209625244, 6.29147481918335, 6.265127182006836, 6.239115238189697, 6.213438034057617, 6.1880879402160645, 6.16306209564209, 6.1383538246154785, 6.113958358764648, 6.089870929718018, 6.066088676452637, 6.042604923248291, 6.0194172859191895, 5.99652099609375, 5.973909854888916, 5.951583385467529, 5.929533004760742, 5.9077606201171875, 5.886258125305176, 5.8650221824646, 5.84404993057251, 5.823337554931641, 5.802882671356201, 5.782680034637451, 5.7627272605896, 5.743020057678223, 5.723556041717529, 5.704329967498779, 5.6853437423706055, 5.666589260101318, 5.648065090179443, 5.629768371582031, 5.611696720123291, 5.593847274780273, 5.576216697692871, 5.558801174163818, 5.541601181030273, 5.524610996246338, 5.507828712463379, 5.49125337600708, 5.474881649017334, 5.458709239959717, 5.442737579345703, 5.426959991455078, 5.411378383636475, 5.395987510681152, 5.3807854652404785, 5.365771770477295, 5.350942611694336, 5.336297035217285, 5.321832180023193, 5.307546138763428, 5.293436050415039, 5.279501914978027, 5.265741348266602, 5.252151966094971, 5.238731861114502, 5.225479602813721, 5.212392807006836, 5.199471473693848, 5.186710834503174, 5.174088478088379, 5.161648750305176, 5.1493659019470215, 5.137239456176758, 5.125267028808594, 5.113447189331055, 5.101779460906982, 5.090260982513428, 5.078890800476074, 5.067667007446289, 5.056589603424072, 5.045656204223633, 5.034865379333496, 5.024216175079346, 5.013708114624023, 5.003337383270264, 4.993104934692383, 4.9830098152160645, 4.973048210144043, 4.963222980499268, 4.95352840423584, 4.943966865539551, 4.934535026550293, 4.925233364105225, 4.916059494018555, 4.907012939453125, 4.8980937004089355, 4.8892998695373535, 4.880629062652588, 4.872082710266113, 4.072032928466797, 3.998302698135376, 3.966073751449585, 3.9414217472076416, 3.9218642711639404, 3.9066898822784424, 3.8938684463500977, 3.882819890975952, 3.874840021133423, 3.8669657707214355, 3.8619132041931152, 3.8579494953155518, 3.8540663719177246, 3.8532791137695312, 3.852914571762085, 3.852623224258423, 3.8556814193725586, 3.8588790893554688, 3.8625941276550293, 3.869584321975708, 3.8766725063323975, 3.8857944011688232, 3.897467851638794, 3.909691333770752, 3.9275567531585693, 3.9465341567993164, 3.974195957183838, 4.013400077819824, 4.6740031242370605, 4.668774127960205, 4.663647651672363, 4.6586198806762695, 4.653691291809082, 4.648862838745117, 4.644130706787109, 4.639497756958008, 4.63496208190918, 4.630522727966309, 4.626180648803711, 4.621934413909912, 4.617784023284912, 4.613729000091553, 4.609766960144043, 4.605901718139648, 4.602129936218262, 4.598450660705566, 4.594865798950195, 4.591372489929199, 4.587973594665527, 4.5846662521362305, 4.581450462341309, 4.578325271606445, 4.575293064117432, 4.572351455688477, 4.5695013999938965, 4.566739559173584, 4.5640692710876465, 4.561488628387451, 4.5589985847473145, 4.556598663330078, 4.554262161254883, 4.552038192749023, 4.549903869628906, 4.547857284545898, 4.545900821685791, 4.544031143188477, 4.54224967956543, 4.540555477142334, 4.538949966430664, 4.537431716918945, 4.535999774932861, 4.534657001495361, 4.53339958190918, 4.532230377197266, 4.531147003173828, 4.530149936676025, 4.52924108505249, 4.528416633605957, 4.527681350708008, 4.527030944824219, 4.5264668464660645, 4.525989532470703, 4.525599479675293, 4.525293827056885, 4.525074005126953, 4.524942874908447, 4.524895191192627]
     
[lidarTime, robotX_actual, robotY_actual, robotTheta_actual, \
  num_points, scanning_angle, start_angle, step_size, jfidar_data] \
             = slam_obj.process_lidar_data(lidar_data)

robotPos = [robotX_actual, robotY_actual, robotTheta_actual]
unrobotPos = robotPos
SR = 0 
SL = 0 

# Case -1, just run it once 

odometry_data = [0, SL, SR]


print('robot state beofre localizing')
print(robotPos)

[robotX, robotY, robotTheta] = slam_obj.localize_and_map(odometry_data, lidar_data, robotPos, unrobotPos, SR, SL)

print('robot Pos after localizing')

print('RobotX ', robotX)
print('robotY: ', robotY)
print('Robot Theta ', robotTheta)



# Testing the draw covariance method 

# =============================================================================
# ellipse = slam_obj.confidence_ellipse(0, 0, np.array([[1, 0],[0, 1]]))
# 
# print('ellipse')
# print(ellipse)
# fig, ax = plt.subplots()
# ax.add_patch(ellipse)
# fig.show()
# 
# =============================================================================
