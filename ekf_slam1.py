# -*- coding: utf-8 -*-
"""
Created on Thu Feb  2 18:10:04 2023

@author: Hp
"""


import localization_constants 
import robot_params
import numpy as np 
import math
import matplotlib.pyplot as plt

# Input --> Lidar_data, robot_pos, unrobot_pos, delta L, delta R, covariance: P
# Output --> Corrected Robot Pos, unrobot_pos

class EKF_slam():
    
    #Declare constants nad process lidar data
    def __init__(self):
    
        # Declaring Constants 
        pass
        
    # Perform the entire localize and mapping algorithm   
    # Inputs --> None
    # Outputs --> Corrected Robot Pos, unrobot_pos
    
    
    def localize_and_map(self, odometry_data, Lidar_data, robot_state,unlocalized_pos, SR, SL, P) -> list:
        
        # Preprocess Lidar Data        
        [lidarTime, robotX_actual, robotY_actual, robotTheta_actual, \
            num_points, scanning_angle, start_angle, step_size, lidar_data] \
            = self.process_lidar_data(Lidar_data)
        
        

        # Extract the Odometry Data --> get SL and SR
        [_, SL, SR] = odometry_data
        
    
        # Extract Local Variables 
        robotPos = robot_state[0:3]
        robotX, robotY, robotTheta = robotPos
        Q = self.get_Q(SR, SL)
        R = localization_constants.R
        
        # Propagate Robot --> Poshat, unrobot
        [robotX_hat, robotY_hat, robotTheta_hat] = self.get_pred_pos(SL, SR, robotPos)
        unlocalized_pos = self.get_pred_pos(SL, SR, unlocalized_pos)
 
        # Compute Jacobians 
        Fu = self.get_Fu(SR, SL, robotTheta_hat, robot_state.shape)
        Fp = self.get_Fp(SR, SL, robotTheta_hat, robot_state.shape)
        
        
        # Updata pred cov     
        P_hat = self.get_Phat(P, Fu, Fp)
        
        # Obtain Correspondences  
        
        [cylinders, derivatives] = self.find_cylinders(robotX_bar, robotY_bar, robotTheta_bar, lidar_data)
        
        cylinder_pairs = self.get_cylinder_pairs(lidar_data, robot_pos)
        
        # Obtain Observations 
        z = self.get_observations(cylinder_pairs, robot_pos)
        
        # Obtain Predicted Observations 
        
        zhat = self.get_pred_obs(robot_pos)
        
        # Compute Obs Jacobians 
        
        H = self.compute_obs_jacobian()
        
        # Compute Kalman Gain 
        
        K = self.compute_kalman_gain(Phat, H )
        
        # Update State 
        
        robotX, robotY, robotTheta = self.update_pos()
        P = self.update_uncertainity()
        
        # Return
        
        return [robotX, robotY, robotTheta, P]
        
        
        pass
    
    def get_pred_pos(self,SL, SR, robotPos )-> list:
        
        robotX, robotY, robotTheta = robotPos
        b = robot_params.pioneer_track_width
        
        delta_trans = (SL + SR) / 2 
        #delta_theta = (SR- SL) / (2 * b)
        
        robotX = robotX + delta_trans * math.cos(robotTheta + (SR- SL) / (2 * b))
        robotY = robotY + delta_trans * math.sin(robotTheta + (SR- SL) / (2 * b))
        
        robotTheta = robotTheta + (SR - SL) / ( b)
        
        return [robotX, robotY, robotTheta]


    def process_lidar_data(self, data):
        
        sysTime = data[1]
        
        robotX_actual = data[2]
        robotY_actual = data[3]
        robotTheta_actual = data[4]
        
        num_points = int(data[5])
        scanning_angle = data[6]
        start_angle = 0
        
        step_size = data[8]
        
        lidar_data = data[9:]
        
        lidar_data_processed = []
        angle = start_angle
        
        for i in range(num_points):
            
            lidar_data_processed.append([angle, lidar_data[i]])
            angle+= step_size
            
            
        return [sysTime, robotX_actual, robotY_actual, robotTheta_actual, \
            num_points, scanning_angle, start_angle, step_size, lidar_data_processed]
    
    def get_Q(self, SR, SL):
        k = localization_constants.model_cov_const
        Q = np.array([[k * abs(SR), 0], [0 , k * abs(SL)]])
        return Q
        
    
    def get_Fu(self, SR, SL, theta, robot_state_shape ):
        
        delta_D = (SR +  SL ) / 2
        delta_theta = (SR - SL) / robot_params.pioneer_track_width
        L = robot_params.pioneer_track_width
        
        Fu1 =  np.array(  [[1/2 * math.cos(theta + delta_theta /2) - delta_D / (2 * L) * math.sin(theta + delta_theta / 2), 1/2 * math.cos(theta + delta_theta /2) + delta_D / (2 * L) * math.sin(theta + delta_theta / 2)       ], \
                         [1/2 * math.sin(theta + delta_theta /2) + delta_D / (2 * L) * math.cos(theta + delta_theta / 2), 1/2 * math.sin(theta + delta_theta /2) - delta_D / (2 * L) * math.cos(theta + delta_theta / 2)       ], \
                         [1 / L, -1/L]    ] ) 
        
        Fu = np.zeros(shape=(robot_state_shape[0], 2))
# =============================================================================
#         print(Fu)
# =============================================================================
        Fu[0:3,:] = Fu1
        
        return Fu
    
    def get_Fp(self, SR, SL, theta, robot_state_shape):
        
        
        delta_D = (SR + SL ) / 2
        delta_theta = (SR - SL) / robot_params.pioneer_track_width
        L = robot_params.pioneer_track_width
        
        Fp1 = np.array(  [[1, 0 , -delta_D * math.sin(theta + delta_theta / 2)], \
                         [0, 1, delta_D * math.cos(theta + delta_theta / 2)], \
                         [0, 0, 1] ]   )
        
        Fp2 = np.eye(robot_state_shape[0]-3)
        Fp = np.zeros(shape=(robot_state_shape[0],robot_state_shape[0] ))
        
        #print(Fp.shape)
        Fp[0:3, 0:3] = Fp1
        Fp[3:, 3:] = Fp2
        
        return Fp
            
    
    def get_Phat(self, P, Fu, Fp, Q):
        
        L_matrix = np.matmul(np.matmul(Fp, P), np.transpose(Fp)) 
        R_matrix = np.matmul(np.matmul(Fu, Q), np.transpose(Fu))
        Phat = np.add(L_matrix, R_matrix)
        
        return Phat 
    
    
    def compute_derivative(self, lidar_data):
            
        # Computing Derivatives 
        derivative = []
        for i in range(1,len(lidar_data)-1):
            l = lidar_data[i-1][1]
            r = lidar_data[i+1][1]
            d = (r- l)/2
            derivative.append(d)
              
        return derivative
        
    def find_cylinders(self, robotX_bar, robotY_bar, robotTheta_bar, derivative):
        
        cylinders = []
        cyl_ind  =[]
        start = False
        for i in range(len(derivative)):
    
            if derivative[i] < -localization_constants.cylinder_threshold_derivative :
                start = True
                avg_angle = 0
                n_indices = 0
                avg_depth = 0
                n_indices = 0
                avg_depth = 0 
                avg_indice = 0
                start = True
            if start == True and derivative[i] > localization_constants.cylinder_threshold_derivative \
                and n_indices > 0:
                avg_indice  = avg_indice / n_indices
                avg_angle = avg_angle / n_indices
                avg_depth = avg_depth / n_indices + localization_constants.cylinder_offset
                if avg_depth> 0.2:
                    
                    theta = robotTheta_bar + avg_angle -math.pi/2                   
                    x = robotX_bar + avg_depth * math.cos(theta)
                    y = robotY_bar + avg_depth * math.sin(theta)                
                    cylinders.append([x, y, avg_depth, avg_angle])
                    cyl_ind.append(avg_indice)
                start = False
            if start == True:
                avg_angle += lidar_data[i+1][0]
              #  print('lidar data angle ',lidar_data[i+1][0])
                avg_indice += i
                n_indices += 1
                avg_depth += lidar_data[i+1][1]
            
        
        return cylinders, cyl_ind 
        
        
    
    def get_cylinder_pairs(self):
        
        
        
        pass
    
    def get_observations(self):
        pass
    
    def get_pred_obs(self):
        pass
    
    def compute_obs_jacobian(self):
        pass

    def compute_kalman_gain(self,Phat, H ):
        pass
    
    def update_pos(self):
        pass
    


def plot_derivate(derivative, cyl_ind):
    
    tick = [i for i in range(len(derivative))]
    plt.plot(tick, derivative)
        
    for i in cyl_ind:
        plt.scatter(i-1, 2, c='b')

if __name__ =="__main__":
    
    # Test Input for each function 
    slam_obj = EKF_slam()
    # Testing Fu 
    print('Testing Fu')
    SL = 1
    SR = 1
    
    Theta = 0 
    robot_state = np.zeros(shape=(7,1))
    robot_state_shape = robot_state.shape
    
# =============================================================================
#     
#     print('Testing P')
#     P = np.eye(robot_state_shape[0])
#     print("P: ")
#     print(P)
#     
#     
#     Fu = slam_obj.get_Fu(SR, SL, Theta, robot_state_shape)
#     print('Fu: ')
#     print(Fu)
#     
#     
#     # Testing Fp 
#     
#     print('Testing Fp')
#   
#     Fp = slam_obj.get_Fp(SR, SL, Theta, robot_state_shape)
#     print('Fp: ')
#     print(Fp)
#     
#     
#     # Testing Q 
#     print('Testing Q')
#     Q = slam_obj.get_Q(SR, SL)
#     print(Q)
#     
#     
#     
#     print('Testing Phat')
#     
#     
#     Phat = slam_obj.get_Phat(P, Fu, Fp, Q)
#     print(Phat)
#     
# =============================================================================
    
# Processing Lidar Data
# Obtainign lidar data from main script
    
    print('lidar data:')
    lidar_data = [-1.0, 10473.701171875, 0.9780023694038391, -2.15093994140625, 0.00012135301221860573, 721.0, 3.1415927410125732, -1.5707963705062866, 0.004363323096185923, 5.17432165145874, 5.174373149871826, 5.174522876739502, 5.174771308898926, 5.175119400024414, 5.175563812255859, 5.1761088371276855, 5.1767497062683105, 5.177492141723633, 5.178333282470703, 5.179272174835205, 5.1803107261657715, 5.181448459625244, 5.182685852050781, 5.184020519256592, 5.1854567527771, 5.186990737915039, 5.188626289367676, 5.190359592437744, 5.192195415496826, 5.194129467010498, 5.196140766143799, 5.198276519775391, 5.200512886047363, 5.202852249145508, 5.205291271209717, 5.207830429077148, 5.210472106933594, 5.213216304779053, 5.216063976287842, 5.2190117835998535, 5.2220635414123535, 5.225218772888184, 5.228476047515869, 5.231838226318359, 5.235304832458496, 5.2388739585876465, 5.242550373077393, 5.246330738067627, 5.250216007232666, 5.254208087921143, 5.258306503295898, 5.262510776519775, 5.26682186126709, 5.271241188049316, 5.2757697105407715, 5.2804036140441895, 5.285147190093994, 5.2900004386901855, 5.294964790344238, 5.300040245056152, 5.305224418640137, 5.310519695281982, 5.315928936004639, 5.321448802947998, 5.327083110809326, 5.332828521728516, 5.338689804077148, 5.34466552734375, 5.350758075714111, 5.356964588165283, 5.363286972045898, 5.369729995727539, 5.376288414001465, 5.382966995239258, 5.389763355255127, 5.396681785583496, 5.403718948364258, 5.410879611968994, 5.418160438537598, 5.425564765930176, 5.4330949783325195, 5.440746784210205, 5.4485273361206055, 5.456432342529297, 5.464463710784912, 5.472626209259033, 5.480913162231445, 5.4893341064453125, 5.497881889343262, 5.506563663482666, 5.515379905700684, 5.524325847625732, 5.533409118652344, 5.542625904083252, 5.551980972290039, 5.561473846435547, 5.571105003356934, 5.580874919891357, 5.590787410736084, 5.600841999053955, 5.611038684844971, 5.621379375457764, 5.6318678855896, 5.642502784729004, 5.65328311920166, 5.664215564727783, 5.67529821395874, 5.686531066894531, 5.697918891906738, 5.709460258483887, 5.721136569976807, 5.732993125915527, 5.745007038116455, 5.757181644439697, 5.769516468048096, 5.782014846801758, 5.794681072235107, 5.8075103759765625, 5.820509433746338, 5.833677768707275, 5.847017765045166, 5.860530853271484, 5.874217510223389, 5.888082027435303, 5.902124404907227, 5.916345119476318, 5.930750370025635, 5.945337295532227, 5.96011209487915, 5.975071907043457, 5.990222930908203, 6.005565643310547, 6.021101474761963, 6.0368332862854, 6.052762985229492, 6.068891525268555, 6.085227012634277, 6.1017608642578125, 6.118507385253906, 6.135459899902344, 6.152623176574707, 6.170003890991211, 6.187600612640381, 6.2054123878479, 6.223449230194092, 6.241708755493164, 6.260199069976807, 6.278915882110596, 6.297865867614746, 6.317050933837891, 6.336474418640137, 6.356139183044434, 6.376047611236572, 6.396204948425293, 6.416610240936279, 6.437271595001221, 6.458189964294434, 6.479365825653076, 6.5008063316345215, 6.522515296936035, 6.544493198394775, 6.566744327545166, 6.5892744064331055, 6.612085819244385, 6.635182857513428, 6.658567428588867, 6.682247161865234, 6.706222057342529, 6.730501651763916, 6.7550835609436035, 6.7799763679504395, 6.805181503295898, 6.830615997314453, 6.856463432312012, 6.8826398849487305, 6.909147262573242, 6.935995578765869, 6.963184833526611, 6.99072265625, 7.018610000610352, 7.046859264373779, 7.075470447540283, 7.104449272155762, 7.133803844451904, 7.163539409637451, 7.193661689758301, 7.224177360534668, 7.2550883293151855, 7.286407470703125, 7.318138122558594, 7.350283622741699, 7.382857322692871, 7.415862560272217, 7.449304103851318, 2.576115131378174, 2.542250394821167, 2.5206985473632812, 2.5017201900482178, 2.486928939819336, 2.474801540374756, 2.462836980819702, 2.45328426361084, 2.445448637008667, 2.437708854675293, 2.430063486099243, 2.4249215126037598, 2.420215606689453, 2.4155733585357666, 2.4109954833984375, 2.4078915119171143, 2.405707359313965, 2.4035725593566895, 2.4014875888824463, 2.3995375633239746, 2.3996291160583496, 2.399765729904175, 2.3999481201171875, 2.400177240371704, 2.401209592819214, 2.403629779815674, 2.4061005115509033, 2.4086227416992188, 2.411195993423462, 2.4157400131225586, 2.420773506164551, 2.425872564315796, 2.431041717529297, 2.4381496906280518, 2.4464006423950195, 2.454754590988159, 2.463301181793213, 2.476029396057129, 2.4889395236968994, 2.5028109550476074, 2.523218870162964, 2.5441837310791016, 2.5819413661956787, 7.597679615020752, 7.57628870010376, 7.5551629066467285, 7.534296035766602, 7.513688087463379, 7.49333381652832, 7.473232746124268, 7.4533796310424805, 7.433772563934326, 7.414411544799805, 7.395289897918701, 7.376405715942383, 7.357757091522217, 7.3393449783325195, 6.5990118980407715, 6.537219047546387, 6.500204563140869, 6.473877906799316, 6.454679489135742, 6.441795825958252, 6.431609630584717, 6.426163673400879, 6.4237589836120605, 6.424132347106934, 6.428967475891113, 6.435617446899414, 6.448139190673828, 6.464375972747803, 6.485396385192871, 6.5160956382751465, 6.561623573303223, 7.045222282409668, 7.030825138092041, 7.016619682312012, 7.00260591506958, 6.988778114318848, 6.97514009475708, 6.961687088012695, 6.948416233062744, 6.935329914093018, 6.922422885894775, 6.909694194793701, 6.897146701812744, 6.884773254394531, 6.872573375701904, 6.8605499267578125, 6.848697185516357, 6.837015628814697, 6.825502872467041, 6.814157962799072, 6.802981376647949, 6.79196834564209, 6.781121730804443, 6.770437717437744, 6.759915351867676, 6.749556541442871, 6.739354133605957, 6.729313850402832, 6.719429969787598, 6.709702491760254, 6.70012903213501, 6.69071102142334, 6.681447982788086, 6.672333717346191, 6.663374423980713, 6.654563903808594, 6.645904064178467, 6.637389659881592, 6.629027366638184, 6.620810508728027, 6.612740993499756, 6.604813575744629, 6.597033500671387, 6.58939790725708, 6.581902503967285, 6.574549674987793, 6.5673370361328125, 6.560266971588135, 6.553337097167969, 6.546543598175049, 6.539888381958008, 6.533374786376953, 6.526997089385986, 6.520753860473633, 6.514649391174316, 6.5086774826049805, 6.502840995788574, 6.497138023376465, 6.491571426391602, 6.486135482788086, 6.480831146240234, 6.4756598472595215, 6.470618724822998, 6.465710163116455, 6.460930824279785, 6.45628023147583, 6.451761722564697, 6.447369575500488, 6.443107604980469, 6.438973426818848, 6.434968948364258, 6.431089878082275, 6.427337646484375, 6.423709869384766, 6.4202141761779785, 6.416839122772217, 6.413590431213379, 6.4104695320129395, 6.407472133636475, 6.404598236083984, 6.401851177215576, 6.39922571182251, 6.396726131439209, 6.394349098205566, 6.392097473144531, 6.389966011047363, 6.387958526611328, 6.386075019836426, 6.384312629699707, 6.382674694061279, 6.381156921386719, 6.379761695861816, 6.3784894943237305, 6.377338409423828, 6.376309871673584, 6.375402450561523, 6.374617576599121, 6.373951435089111, 6.373409271240234, 6.372987270355225, 6.372687816619873, 6.372509479522705, 6.3724517822265625, 6.3725152015686035, 6.372702121734619, 6.3730082511901855, 6.373436450958252, 6.373985767364502, 5.806485176086426, 5.719326496124268, 5.6798577308654785, 5.651911735534668, 5.632760047912598, 5.6166815757751465, 5.605134010314941, 5.596602916717529, 5.590743064880371, 5.587821006774902, 5.5870747566223145, 5.589178562164307, 5.593479156494141, 5.600964069366455, 5.610722064971924, 5.625113487243652, 5.641877174377441, 5.6665472984313965, 5.699766635894775, 5.751496315002441, 6.413769721984863, 6.417023181915283, 6.420403003692627, 6.423910140991211, 6.427543640136719, 6.431301593780518, 6.435187339782715, 6.439201831817627, 6.443342685699463, 6.447612762451172, 6.452010154724121, 6.456535816192627, 6.461193084716797, 6.465979099273682, 6.470894813537598, 6.475943565368652, 6.4811224937438965, 6.486433982849121, 6.491876602172852, 6.497452735900879, 6.503161907196045, 6.509006023406982, 6.514985084533691, 6.521098613739014, 6.527348041534424, 6.533735275268555, 6.540256977081299, 6.5469183921813965, 6.553716659545898, 6.560657024383545, 6.567735195159912, 6.574953556060791, 6.582314491271973, 6.589818000793457, 6.5974626541137695, 6.605251312255859, 6.613184928894043, 6.621264457702637, 6.629488945007324, 6.637861728668213, 6.646381378173828, 6.655048370361328, 6.663867473602295, 6.672836780548096, 6.681957721710205, 6.691230297088623, 6.700657844543457, 6.710236549377441, 6.719974994659424, 6.729866981506348, 6.739918231964111, 6.750129222869873, 6.760497570037842, 6.771029949188232, 6.781721115112305, 6.792576313018799, 6.803598880767822, 6.814784049987793, 6.826138019561768, 6.83765983581543, 6.84935188293457, 6.861213207244873, 6.8732476234436035, 6.885456562042236, 6.897838115692139, 6.910398006439209, 2.8496570587158203, 2.792526960372925, 2.7633419036865234, 2.7419021129608154, 2.724809408187866, 2.7111709117889404, 2.697718620300293, 2.6880533695220947, 2.679232597351074, 2.670520067214966, 2.6634128093719482, 2.658001184463501, 2.6526620388031006, 2.6473946571350098, 2.6438205242156982, 2.6412134170532227, 2.638660430908203, 2.6361632347106934, 2.634840250015259, 2.6347408294677734, 2.634692668914795, 2.6346936225891113, 2.6352603435516357, 2.637655258178711, 2.6401045322418213, 2.642608404159546, 2.6453301906585693, 2.6504762172698975, 2.6556925773620605, 2.6609811782836914, 2.666991949081421, 2.675541400909424, 2.6841955184936523, 2.692958354949951, 2.705475330352783, 2.7188541889190674, 2.7331185340881348, 2.7540693283081055, 2.776644229888916, 2.8142008781433105, 6.027677059173584, 7.620547294616699, 7.642490386962891, 7.664705753326416, 7.687194347381592, 7.709963321685791, 7.733018398284912, 7.756358623504639, 7.779988765716553, 7.803911209106445, 7.792598247528076, 7.745301246643066, 7.698722839355469, 7.652843475341797, 7.607651233673096, 7.563136100769043, 7.519282817840576, 7.476073265075684, 7.433497905731201, 7.391545295715332, 7.350203514099121, 7.309460639953613, 7.269300937652588, 7.229719161987305, 7.190704822540283, 7.15224027633667, 7.114321708679199, 7.076937675476074, 7.040076732635498, 7.003733158111572, 6.967891693115234, 6.932547569274902, 6.897693157196045, 6.863314628601074, 6.829404830932617, 6.795962810516357, 6.762969970703125, 6.730425834655762, 6.69831657409668, 6.6666436195373535, 6.635392665863037, 6.604557991027832, 6.57413387298584, 6.5441131591796875, 6.514485836029053, 6.4852519035339355, 6.456400394439697, 6.427926063537598, 6.3998212814331055, 6.372084140777588, 6.3446550369262695, 6.317630767822266, 6.290955066680908, 6.264623165130615, 6.238629341125488, 6.2129693031311035, 6.187634468078613, 6.162622928619385, 6.137930870056152, 6.11354923248291, 6.089476108551025, 6.065707683563232, 6.042240142822266, 6.01906681060791, 5.996183395385742, 5.9735870361328125, 5.951272964477539, 5.9292378425598145, 5.907477855682373, 5.885988235473633, 5.8647637367248535, 5.843804836273193, 5.823105335235596, 5.802661895751953, 5.782470226287842, 5.762529373168945, 5.742833614349365, 5.723381042480469, 5.704168319702148, 5.685191631317139, 5.666448593139648, 5.6479363441467285, 5.629648685455322, 5.611588954925537, 5.593749523162842, 5.5761284828186035, 5.558725833892822, 5.541534423828125, 5.524555206298828, 5.507782936096191, 5.49121618270874, 5.474853992462158, 5.458693027496338, 5.442728519439697, 5.426961898803711, 5.411388397216797, 5.396007537841797, 5.380814552307129, 5.365808010101318, 5.35098934173584, 5.336350917816162, 5.321896076202393, 5.3076171875, 5.29351806640625, 5.279590606689453, 5.265838623046875, 5.25225830078125, 5.2388458251953125, 5.2256011962890625, 5.212523460388184, 5.199608325958252, 5.186855316162109, 5.174240589141846, 5.16180944442749, 5.149533748626709, 5.137415409088135, 5.125450611114502, 5.113636493682861, 5.101974964141846, 5.090465545654297, 5.0791015625, 5.067885875701904, 5.056814193725586, 5.045888900756836, 5.035103797912598, 5.024462699890137, 5.0139617919921875, 5.003598213195801, 4.99337100982666, 4.983282566070557, 4.97332763671875, 4.963508605957031, 4.953819751739502, 4.944264888763428, 4.934841632843018, 4.925544261932373, 4.916377067565918, 4.907338619232178, 4.89842414855957, 4.8896355628967285, 4.880971431732178, 4.872430801391602, 4.055324554443359, 3.9946088790893555, 3.96394944190979, 3.940589427947998, 3.921048402786255, 3.906667709350586, 3.8938546180725098, 3.88338565826416, 3.8754100799560547, 3.867541551589966, 3.8629653453826904, 3.8590056896209717, 3.8552093505859375, 3.8547756671905518, 3.8544158935546875, 3.8545002937316895, 3.8576252460479736, 3.8608295917510986, 3.8650240898132324, 3.872023582458496, 3.8791229724884033, 3.888827323913574, 3.9005167484283447, 3.9135265350341797, 3.9314208030700684, 3.9516384601593018, 3.9793546199798584, 4.021078109741211, 4.674515724182129, 4.6692938804626465, 4.66417121887207, 4.659148216247559, 4.654225826263428, 4.649401664733887, 4.644675254821777, 4.640047550201416, 4.6355180740356445, 4.63108491897583, 4.626747131347656, 4.622506618499756, 4.61836051940918, 4.614309787750244, 4.610353946685791, 4.6064934730529785, 4.602726459503174, 4.599052429199219, 4.595472812652588, 4.59198522567749, 4.588590621948242, 4.585288047790527, 4.582077980041504, 4.578958511352539, 4.575931549072266, 4.572994232177734, 4.570148944854736, 4.5673933029174805, 4.564728260040283, 4.56215238571167, 4.559667110443115, 4.5572710037231445, 4.5549397468566895, 4.552722930908203, 4.550594329833984, 4.5485520362854, 4.546600341796875, 4.544736862182617, 4.542959690093994, 4.541271686553955, 4.539670467376709, 4.538156986236572, 4.536731243133545, 4.535391807556152, 4.5341410636901855, 4.532976150512695, 4.531898498535156, 4.530907154083252, 4.530002593994141, 4.529184818267822, 4.528453826904297, 4.527808666229248, 4.527249813079834, 4.526778697967529, 4.526391983032227, 4.526092529296875, 4.525879383087158, 4.52575159072876, 4.5257110595703125]
    
    print('processed lidar')
    
    [lidarTime, robotX_actual, robotY_actual, robotTheta_actual, \
        num_points, scanning_angle, start_angle, step_size, lidar_data] \
        = slam_obj.process_lidar_data(lidar_data)
    
    print(lidar_data)
    
    # Testing the derivative funcituon 
    
    print('Testing the derivative fuction ')
    
    derivative = slam_obj.compute_derivative(lidar_data)
    
    
    
    
    
    
    # Testing the find cylinders funciton 
    robotX_bar, robotY_bar, robotTheta_bar = [0, 0, 0]
    cylinders, cyl_ind = slam_obj.find_cylinders(robotX_bar, robotY_bar, robotTheta_bar, derivative)
    
    print('cylinders')
    print(cylinders)
    
    print('cyl ind')
    print(cyl_ind)
    
    # Helper function to plot the derivative 
    plot_derivate(derivative, cyl_ind)
    
    
    
    # Testing the get cylinder pairs function 
    
    
    
    

    
    